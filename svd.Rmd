---
title: "Simulaciones SVD"
date: "Septiembre de 2020"
output: 
  html_document:
    theme: cosmo
lang: es
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


## Coeficiente de variación

El peso de los primeros singular values depende del coeficiente de variación de las columnas (la relación entre desvío y media).

```{r }
set.seed(55)
columnas = replicate(n=4, rnorm(n, 200, 50))
mat = columnas

svd_obj = svd(mat)
svd_obj$d / sum(svd_obj$d)

```

En los dos siguientes escenarios se aumenta el coeficiente de variación (CV) y el primer singular value sube. En ambos escenarios el CV es el mismo

```{r }
set.seed(55)
columnas = replicate(n=4, rnorm(n, 200, 1))
mat = columnas

svd_obj = svd(mat)
cat("CV = ", 200/1,"\n")
cat(svd_obj$d / sum(svd_obj$d))

```
```{r }
set.seed(55)
columnas = replicate(n=4, rnorm(n, 10000, 50))
mat = columnas

svd_obj = svd(mat)
cat("CV = ", 10000/50, "\n")
cat(svd_obj$d / sum(svd_obj$d))

```

La conclusión es que reescalar toda la matriz por una constante (por ejemplo, multiplicar todo por 1000) no altera los resultados. Por ejemplo:

```{r }
set.seed(55)
columnas = replicate(n=4, rnorm(n, 200, 1)) * 1000
mat = columnas

svd_obj = svd(mat)
svd_obj$d / sum(svd_obj$d)

```

Si sube el CV, el peso de los primeros singular values cae; es más difícil reconstruir la matriz original con la misma cantidad de singular values/vectors.

```{r }
set.seed(55)
columnas = replicate(n=4, rnorm(n, 200, 50))
mat = columnas

svd_obj = svd(mat)
cat("CV = ", 200/50, "\n")
cat(svd_obj$d / sum(svd_obj$d))

```


## Vectores de medias 

```{r }
set.seed(55)
columnas = replicate(n=4, rnorm(n, 200, 50))
mat = columnas

svd_obj = svd(mat)
cat(svd_obj$d / sum(svd_obj$d))
svd_obj$v

```


```{r }
set.seed(55)
columnas = replicate(n=4, rnorm(n, 200, 50))
columnas[,3:4] = columnas[,3:4] / 200
mat = columnas
# # equivalente a:
# high = replicate(n=2, rnorm(n, 200, 50))
# low = replicate(n=2, rnorm(n, 1, 0.25))
# mat = cbind(high, low)

svd_obj = svd(mat)
cat(svd_obj$d / sum(svd_obj$d))
svd_obj$v
apply(mat, 2, function(x) sd(x)/mean(x))

```

Las columnas relevantes (con valor absoluto alto en los right singular vectors asociados a singular values altos) tienen una "media relativa alta" -- es decir, son las de mayor media en relación a las otras columnas, suponiendo que los CV de todas las columnas son iguales. 

Además, el peso de los primeros singular values depende de la cantidad de columnas relevantes (relevante según el valor promedio). Es decir, si se reescalan algunas columnas y se mantiene constante el CV de todas, crecerá el valor de los primeros singular values. Reescalar algunas columnas sí altera los resultados. 

Esto es distinto a lo que pasa en regresión lineal o en componentes principales, donde la escala es "irrelevante" y lo que importa es la variabilidad de cada variable.

Los cambios en el CV de las columnas irrelevantes (con medias bajas) repercuten mucho menos en los resultados que los cambios en las columnas de media alta. Por ejemplo:


```{r }
set.seed(55)
high = replicate(n=2, rnorm(n, 200, 100))
low = replicate(n=2, rnorm(n, 1, 0.25))
mat = cbind(high, low)

svd_obj = svd(mat)
cat(svd_obj$d / sum(svd_obj$d))

```

```{r }
set.seed(55)
high = replicate(n=2, rnorm(n, 200, 50))
low = replicate(n=2, rnorm(n, 1, 0.5))
mat = cbind(high, low)

svd_obj = svd(mat)
cat(svd_obj$d / sum(svd_obj$d))

```


## Correlaciones

Si aumenta la correlación entre dos columnas, ceteris paribus, aumenta el peso de los primeros singular values: es más facil reconstruir la matriz original porque hay columnas que "repiten información".

```{r }
set.seed(55)
high = replicate(n=2, rnorm(n, 200, 50))
low = replicate(n=2, rnorm(n, 1, 0.25))
mat = cbind(high, low)

cor(mat)

svd_obj = svd(mat)
svd_obj$d / sum(svd_obj$d)
svd_obj$v

```



```{r }
set.seed(55)
high = replicate(n=2, rnorm(n, 200, 50))
low = replicate(n=2, rnorm(n, 1, 0.25))
high[,2] = high[,1] * -2 + runif(n)
mat = cbind(high, low)

cor(mat)

svd_obj = svd(mat)
svd_obj$d / sum(svd_obj$d)
svd_obj$v

```


La correlación alta negativa/positiva entre dos columnas no sería lo mismo que valores bajos en valor absoluto (casi cero) de una columna, se corresponda con valores altos de otra, y viceversa (por ejemplo, los jugadores que tiran de 3 no tiran de 2, y lo mismo al revés). En este escenario las variables (cantidad de triples y dobles, por ejemplo) están correlacionadas mediadas por una variable binaria latente ("tipo de tirador"), y eso no es exactamente lo mismo que correlacion absoluta alta. Parecería que los valores cercanos a cero importan.


TODO:
- como afectan correlaciones mas altas entre las columnas?
- como afecta la estructura de las filas?
